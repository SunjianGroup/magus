import random, logging, os, sys, shutil, time, json
import argparse
import copy
import numpy as np
from ase.data import atomic_numbers
from ase import Atoms, Atom
import ase.io
from .initstruct import read_seeds,build_mol_struct
from .utils import *
from .machinelearning import LRmodel
from .parameters import magusParameters
from .writeresults import write_results
from .offspring_creator import RattleMutation,PopGenerator
"""
Pop:class,poplulation
pop:list,a list of atoms
Population:Population(pop) --> Pop
"""
#TODO build mol struct
#TODO change read parameters
class Magus:
    def __init__(self,parameters):
        self.parameters = parameters.parameters
        self.Generator = parameters.get_AtomsGenerator()
        self.Algo = parameters.get_PopGenerator()
        self.MainCalculator = parameters.get_MainCalculator()
        self.Population = parameters.get_Population()
        if self.parameters.useml:
            self.ML = parameters.get_MLCalculator()

        self.curgen = 1
        self.bestlen = []
        self.allPop = self.Population([],'allPop')
        self.Population.allPop = self.allPop
        self.kappa = 2
        self.dualpoint = True

    def run(self):
        self.Initialize()
        for gen in range(self.parameters.numGen-1):
            self.Onestep()
            #if gen > 5 and self.bestlen[gen] == self.bestlen[gen-5]:
            #    logging.info('converged')
            #    break

    def Initialize(self):
        if os.path.exists("results"):
            i=1
            while os.path.exists("results{}".format(i)):
                i+=1
            shutil.move("results", "results{}".format(i))
        os.mkdir("results")
        self.parameters.save('allparameters.yaml')
        self.parameters.save('results/allparameters.yaml')

        #shutil.copy("allParameters.yaml", "results/allParameters.yaml")
        logging.info("===== Generation {} =====".format(self.curgen))
        if not self.parameters.molMode:
            initpop = self.Generator.Generate_pop(self.parameters.initSize,initpop=True)
        else:
            initpop = build_mol_struct(self.parameters.initSize, self.parameters.symbols,
                self.parameters.formula, self.parameters.inputMols, self.parameters.molFormula,
                self.parameters.numFrml, self.parameters.spacegroup,
                fixCell=self.parameters.fixCell, setCellPar=self.parameters.setCellPar)
        initPop = self.Population(initpop,'initpop',self.curgen)
        logging.info("initPop length: {}".format(len(initPop)))

        #read seeds
        seedpop = read_seeds(self.parameters, '{}/Seeds/POSCARS_{}'.format(self.parameters.workDir, self.curgen))
        seedPop = self.Population(seedpop,'seedpop',self.curgen)
        if self.parameters.chkSeed:
            seedPop.check()
        initPop.extend(seedPop)
        initpop = self.MainCalculator.scf(initPop.frames)
        initPop = self.Population(initpop,'initpop',self.curgen)
        initPop.check()
        initPop.del_duplicate()
        initPop.save()

        if self.parameters.useml:
            self.ML.updatedataset(initPop.all_frames)
            self.ML.train()
            logging.info("loss:\nenergy_mse:{}\tenergy_r2:{}\nforce_mse:{}\tforce_r2:{}".format(*self.ML.get_loss(initPop.all_frames)[:4]))
            #scfpop = self.MainCalculator.scf(relaxPop.frames)
            #scfPop = self.Population(scfpop,'scfpop',self.curgen)
            #logging.info("loss:\nenergy_mse:{}\tenergy_r2:{}\nforce_mse:{}\tforce_r2:{}".format(*self.ML.get_loss(scfPop.frames)[:4]))


        self.curPop = initPop

    def Onestep(self):
        curPop = self.curPop
        self.curgen+=1
        curPop.save('gen',self.curgen)
        logging.info("===== Generation {} =====".format(self.curgen))
        #######  get next Pop  #######
        # renew volRatio
        volRatio = curPop.get_volRatio()
        self.Generator.updatevolRatio(0.5*(volRatio + self.Generator.p.volRatio))

        initPop = self.Algo.next_Pop(curPop)
        logging.info("Generated by Algo: {}".format(len(initPop)))
        if len(initPop) < self.parameters.popSize:
            logging.info("random structures:{}".format(self.parameters.popSize-len(initPop)))
            if self.parameters.molMode:
                addpop = build_mol_struct(self.parameters.popSize-len(initPop), self.parameters.symbols,
                self.parameters.formula, self.parameters.inputMols, self.parameters.molFormula,
                self.parameters.numFrml, self.parameters.spacegroup,
                fixCell=self.parameters.fixCell, setCellPar=self.parameters.setCellPar)
            else:
                addpop = self.Generator.Generate_pop(self.parameters.popSize-len(initPop))
            logging.debug("addpop: {}".format(len(addpop)))
            initPop.extend(addpop)

        #read seeds
        seedpop = read_seeds(self.parameters, '{}/Seeds/POSCARS_{}'.format(self.parameters.workDir, self.curgen))
        seedPop = self.Population(seedpop,'seedpop',self.curgen)
        if self.parameters.chkSeed:
            seedPop.check()
        initPop.extend(seedPop)

        # Save Initial
        initPop.save('new',self.curgen)

        #######  relax  #######
        kappa = self.kappa
        relaxpop = self.ML.relax(initPop.frames)
        ase.io.write('results/MLrelax{}.traj'.format(self.curgen),relaxpop)
        a_add = []
        for _ in range(3):
            try:
                anew = self.select_with_acquisition(relaxpop, kappa)
                anew = self.evaluate(anew)
                logging.info('xixi')
                logging.info('lowest: {}'.format(anew.info['energy']))
                a_add.append(anew)
                if self.dualpoint:
                    logging.info('yeah!')
                    adp = self.get_dualpoint(anew)
                    adp = self.evaluate(adp)
                    logging.info('dual: {}'.format(adp.info['energy']))
                    a_add.append(adp)
                break
            except Exception as err:
                kappa /=2
        
        # Add structure to population
        index_lowest = np.argmin([a.info['energy'] for a in a_add])
        anew = a_add[index_lowest]
        anew.info['predictE'],anew.info['stdE'] = self.ML.predict_energy(anew,True)
        anew.info['identity'] = len(self.curPop)
        self.curPop.append(anew)
        logging.info('new structrue:\n energy:{}\tpredict:{}\tstd:{}'\
            .format(anew.info['energy'],anew.info['predictE'],anew.info['stdE']))

        self.ML.updatedataset(a_add)
        self.ML.train()
        logging.info("loss:\nenergy_mse:{}\tenergy_r2:{}\nforce_mse:{}\tforce_r2:{}".\
            format(*self.ML.get_loss(self.curPop.all_frames)[:4]))

    def get_dualpoint(self, a, lmax=0.10, Fmax_flat=5):
        """Returns dual-point structure, i.e. the original structure
        perturbed slightly along the forces.
        
        lmax: The atom with the largest force will be displaced by
        this distance
        
        Fmax_flat: maximum atomic displacement. is increased linearely
        with force until Fmax = Fmax_flat, after which it remains
        constant as lmax.
        """
        F = self.ML.predict_forces(a)
        a_dp = a.copy()

        # Calculate and set new positions
        Fmax = np.sqrt((F**2).sum(axis=1).max())
        pos_displace = lmax * F*min(1/Fmax_flat, 1/Fmax)
        pos_dp = a.positions + pos_displace
        a_dp.set_positions(pos_dp)
        return a_dp

    def evaluate(self, a):
        """ Method to evaluate the energy and forces of the selacted
        candidate.
        """
        a = self.MainCalculator.scf([a])[0]
        return a

    def select_with_acquisition(self, structures, kappa):
        acquisition = []
        for atoms in structures:
            preE,stdE = self.ML.predict_energy(atoms,True)
            acquisition.append(preE-kappa*stdE)
            logging.info('preE:{} stdE:{} ac:{}'.format(preE,stdE,preE-kappa*stdE))
        index_select = np.argmin(acquisition)
        return structures[index_select]

parser = argparse.ArgumentParser()
parser.add_argument("--debug", help="print debug information", action='store_true', default=False)
args = parser.parse_args()
if args.debug:
    logging.basicConfig(filename='log.txt', level=logging.DEBUG, format="%(message)s")
    logging.info('Debug mode')
else:
    logging.basicConfig(filename='log.txt', level=logging.INFO, format="%(message)s")

parameters = magusParameters('input.yaml')
m=Magus(parameters)
m.run()
