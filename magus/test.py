import random, logging, os, sys, shutil, time, json
import argparse
import copy
import numpy as np
from ase.data import atomic_numbers
from ase import Atoms, Atom
import ase.io
from .initstruct import read_seeds,build_mol_struct
from .readparm import *
from .utils import *
from .machinelearning import LRmodel

"""
Pop:class,poplulation
pop:list,a list of atoms
Population:Population(pop) --> Pop
"""
class Magus:
    def __init__(self,parameters):
        self.parameters = parameters
        self.Generator = get_atoms_generator(parameters)
        self.Algo = get_pop_generator(parameters)
        self.MainCalculator = get_calculator(parameters)
        self.Population = get_population(parameters)
        self.ML=LRmodel(parameters)
        self.curgen=0

    def run(self):
        self.Initialize()
        for _ in range(self.parameters.numGen):
            self.Onestep()

    def Initialize(self):
        if os.path.exists("results"):
            i=1
            while os.path.exists("results{}".format(i)):
                i+=1
            shutil.move("results", "results{}".format(i))
        os.mkdir("results")

        shutil.copy("allParameters.yaml", "results/allParameters.yaml")
        logging.info("===== Generation {} =====".format(self.curgen))
        if not self.parameters.molMode:
            initpop = self.Generator.Generate_pop(self.parameters.initSize,initpop=True)
            initPop = self.Population(initpop,'initpop',self.curgen)
        else:
            initPop = build_mol_struct(self.parameters.initSize, self.parameters.symbols, self.parameters.formula, self.inputMols, self.parameters.molFormula, self.parameters.numFrml, self.parameters.spacegroup, fixCell=self.parameters.fixCell, setCellPar=self.parameters.setCellPar)
        logging.info("initPop length: {}".format(len(initPop)))

        #read seeds
        seedpop = read_seeds(self.parameters, '{}/Seeds/POSCARS_{}'.format(self.parameters.workDir, self.curgen))
        seedPop = self.Population(seedpop,'seedpop',self.curgen)
        seedPop.check()
        initPop.extend(seedPop)

        initPop.save('init')

        relaxpop = self.MainCalculator.relax(initPop.frames)
        relaxPop = self.Population(relaxpop,'relaxpop',self.curgen)
        relaxPop.check()
        
        if self.parameters.chkMol:
            logging.info("check mols")
            relaxPop = check_mol_pop(relaxPop, self.inputMols, self.parameters.bondRatio)
            logging.info("check survival: {}".format(len(relaxPop)))

        relaxPop.del_duplicate()
        relaxPop.calc_dominators()
        relaxPop.save('raw')

        if self.parameters.mlRelax:
            self.ML.updatedataset(relaxPop.frames)
            self.ML.train()
            scfpop = self.MainCalculator.scf(relaxPop.frames)
            scfPop = self.Population(scfpop,'scfpop',self.curgen)
            logging.info("loss:\nenergy_mse:{}\tenergy_r2:{}\tforce_mse:{}\tforce_r2:{}".format(*self.ML.get_loss(scfPop)[:4]))

        self.curPop = relaxPop
        self.goodPop = self.Population([],'goodpop',self.curgen)
        self.keepPop = self.Population([],'keeppop',self.curgen)

    def Onestep(self):
        curPop = self.curPop
        goodPop = self.goodPop
        keepPop = self.keepPop
        self.curgen+=1
        logging.info("===== Generation {} =====".format(self.curgen))
        #######  get next Pop  #######
        # renew volRatio
        volRatio = curPop.get_volRatio()
        self.Generator.updatevolRatio(0.5*(volRatio + self.Generator.volRatio))

        initPop = self.Algo.next_Pop(curPop)
        logging.debug("Generated by Algo: {}".format(len(initPop)))
        if len(initPop) < self.parameters.popSize:
            logging.info("random structures:{}".format(self.parameters.popSize-len(initPop)))
            addpop = self.Generator.Generate_pop(self.parameters.popSize-len(initPop))
            initPop.extend(addpop)

        #read seeds
        seedpop = read_seeds(self.parameters, '{}/Seeds/POSCARS_{}'.format(self.parameters.workDir, self.curgen))
        seedPop = self.Population(seedpop,'seedpop',self.curgen)
        seedPop.check()
        initPop.extend(seedPop)

        # Save Initial
        initPop.save()

        #######  relax  #######
        if self.parameters.mlRelax:
            for _ in range(10):
                relaxpop = self.ML.relax(initPop.frames)
                relaxPop = self.Population(relaxpop,'relaxpop',self.curgen)
                relaxPop.check()
                scfpop = self.MainCalculator.scf(relaxPop.frames)
                loss = self.ML.get_loss(scfpop)
                if loss[1]>0.8:
                    logging.info('ML Gen{}\tEnergy Error:{}'.format(_,loss[1]))
                    break
                logging.info('QAQ ML Gen{}\tEnergy Error:{}'.format(_,loss[1]))
                self.ML.updatedataset(scfpop)
                write_results(self.ML.dataset,'','dataset',self.parameters.resultsDir)
                self.ML.train()

            else:
                relaxpop = self.MainCalculator.relax(initPop.frames)
                relaxPop = self.Population(relaxpop,'relaxpop',self.curgen)
                logging.info('Turn to main calculator')
        else:
            relaxpop = self.MainCalculator.relax(initPop.frames)
            relaxPop = self.Population(relaxpop,'relaxpop',self.curgen)

        # save raw date before checking
        relaxPop.save('raw')
        relaxPop.check()
        if self.parameters.chkMol:
            logging.info("check mols")
            relaxPop = check_mol_pop(relaxPop, self.inputMols, self.parameters.bondRatio)
            logging.info("check survival: {}".format(len(relaxPop)))
        relaxPop.del_duplicate()
        relaxPop.calc_dominators()
        for ind in relaxPop.pop:
            logging.info("{strFrml} enthalpy: {enthalpy}, fit: {fitness}, dominators: {dominators}"\
                .format(strFrml=ind.atoms.get_chemical_formula(), **ind.info))

        # Write relaxPop
        relaxPop.save('gen')

        #######  goodPop and keepPop  #######
        logging.info('construct goodPop')
        goodPop = relaxPop + goodPop + keepPop
        goodPop.del_duplicate()
        goodPop.select(self.parameters.popSize)
        goodPop.save('good','')
        goodPop.save('savegood')

        # keep best
        logging.info('construct keepPop')
        _, keeppop = goodPop.clustering(self.parameters.saveGood)
        keepPop = self.Population(keeppop,'keeppop',self.curgen)
        keepPop.save('keep')
        
        curPop = relaxPop + keepPop
        curPop.del_duplicate()
        self.curPop = curPop
        self.goodPop = goodPop
        self.keepPop = keepPop

parser = argparse.ArgumentParser()
parser.add_argument("--debug", help="print debug information", action='store_true', default=False)
args = parser.parse_args()
if args.debug:
    logging.basicConfig(filename='log.txt', level=logging.DEBUG, format="%(message)s")
    logging.info('Debug mode')
else:
    logging.basicConfig(filename='log.txt', level=logging.INFO, format="%(message)s")

parameters = read_parameters('input.yaml')
p = EmptyClass()
for key, val in parameters.items():
    setattr(p, key, val)

m=Magus(p)
m.run()
